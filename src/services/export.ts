import { toPng } from 'html-to-image';
import type { MindMap, MindMapNode, KnowledgeGraph } from '../types/mindmap';

function nodeToMarkdown(node: MindMapNode, depth: number = 0): string {
  const indent = '  '.repeat(depth);
  const prefix = depth === 0 ? '# ' : depth === 1 ? '## ' : `${indent}- `;
  const speakerTag = node.speaker ? ` _(${node.speaker})_` : '';
  const typeTag = node.type !== 'topic' && node.type !== 'point' ? ` [${node.type}]` : '';

  let md = `${prefix}${node.label}${speakerTag}${typeTag}\n`;

  for (const child of node.children) {
    md += nodeToMarkdown(child, depth + 1);
  }

  return md;
}

function graphToMarkdown(kg: KnowledgeGraph): string {
  let md = '# Knowledge Graph\n\n';

  // Group entities by type
  const byType = new Map<string, typeof kg.entities>();
  for (const entity of kg.entities) {
    const type = entity.type || 'other';
    if (!byType.has(type)) byType.set(type, []);
    byType.get(type)!.push(entity);
  }

  md += '## Entities\n\n';
  for (const [type, entities] of byType) {
    md += `### ${type.charAt(0).toUpperCase() + type.slice(1)}\n\n`;
    for (const e of entities) {
      md += `- **${e.name}**`;
      if (e.summary) md += `: ${e.summary}`;
      md += '\n';
    }
    md += '\n';
  }

  if (kg.relationships.length > 0) {
    md += '## Relationships\n\n';
    // Build entity name lookup
    const nameMap = new Map(kg.entities.map((e) => [e.id, e.name]));
    for (const r of kg.relationships) {
      const source = nameMap.get(r.source_id) || r.source_id;
      const target = nameMap.get(r.target_id) || r.target_id;
      md += `- ${source} —[${r.type}]→ ${target}: ${r.fact}\n`;
    }
  }

  md += `\n---\n_Generated by MindFlow | ${kg.metadata.last_updated}_\n`;
  return md;
}

export function exportToMarkdown(mindMap: MindMap | null, knowledgeGraph?: KnowledgeGraph | null): string {
  if (knowledgeGraph && knowledgeGraph.entities.length > 0) {
    return graphToMarkdown(knowledgeGraph);
  }

  if (!mindMap) return '';

  let md = nodeToMarkdown(mindMap.root);

  if (mindMap.crossReferences.length > 0) {
    md += '\n---\n\n### Cross-References\n\n';
    for (const ref of mindMap.crossReferences) {
      md += `- ${ref.sourceId} → ${ref.targetId} (${ref.relationship})\n`;
    }
  }

  md += `\n---\n_Generated by MindFlow | ${mindMap.metadata.lastUpdated}_\n`;
  return md;
}

export function exportToJSON(mindMap: MindMap | null, knowledgeGraph?: KnowledgeGraph | null): string {
  if (knowledgeGraph && knowledgeGraph.entities.length > 0) {
    return JSON.stringify(knowledgeGraph, null, 2);
  }
  if (!mindMap) return '{}';
  return JSON.stringify(mindMap, null, 2);
}

function nodeToOPML(node: MindMapNode, indent: number = 2): string {
  const pad = ' '.repeat(indent);
  const attrs = `text="${escapeXml(node.label)}" _type="${node.type}"${
    node.speaker ? ` _speaker="${escapeXml(node.speaker)}"` : ''
  }`;

  if (node.children.length === 0) {
    return `${pad}<outline ${attrs}/>\n`;
  }

  let xml = `${pad}<outline ${attrs}>\n`;
  for (const child of node.children) {
    xml += nodeToOPML(child, indent + 2);
  }
  xml += `${pad}</outline>\n`;
  return xml;
}

function escapeXml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

export function exportToOPML(mindMap: MindMap): string {
  return `<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title>${escapeXml(mindMap.root.label)}</title>
    <dateCreated>${mindMap.metadata.lastUpdated}</dateCreated>
  </head>
  <body>
${nodeToOPML(mindMap.root)}  </body>
</opml>`;
}

export async function exportToPNG(elementId: string): Promise<Blob> {
  const element = document.getElementById(elementId);
  if (!element) throw new Error('Mind map element not found');

  const filter = (node: HTMLElement) => {
    // Exclude UI controls and cross-origin stylesheets
    if (node.tagName === 'LINK' && (node as HTMLLinkElement).href?.includes('fonts.googleapis')) return false;
    return !node.classList?.contains('mindflow-controls');
  };

  try {
    const dataUrl = await toPng(element, {
      backgroundColor: '#0a0a16',
      pixelRatio: 2,
      filter,
    });
    const response = await fetch(dataUrl);
    return response.blob();
  } catch (err) {
    // Retry filtering out all external stylesheets on CORS error
    if ((err as Error).message?.includes('SecurityError') || (err as Error).message?.includes('cssRules')) {
      const dataUrl = await toPng(element, {
        backgroundColor: '#0a0a16',
        pixelRatio: 2,
        filter: (node: HTMLElement) => {
          if (node.tagName === 'LINK' || node.tagName === 'STYLE') return false;
          return !node.classList?.contains('mindflow-controls');
        },
      });
      const response = await fetch(dataUrl);
      return response.blob();
    }
    throw err;
  }
}

export function downloadFile(content: string | Blob, filename: string, mimeType?: string): void {
  const blob =
    content instanceof Blob
      ? content
      : new Blob([content], { type: mimeType || 'text/plain;charset=utf-8' });

  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
